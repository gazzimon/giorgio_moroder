{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@seda-protocol/evm/contracts/interfaces/IRequestHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {SedaDataTypes} from \"../libraries/SedaDataTypes.sol\";\n\n/// @title IRequestHandler\n/// @author Open Oracle Association\n/// @notice Interface for the Request Handler contract.\ninterface IRequestHandler {\n    /// @notice Emitted when a new request is successfully posted\n    /// @param requestId The unique identifier of the posted request\n    event RequestPosted(bytes32 indexed requestId);\n\n    /// @notice Error thrown when a data request parameter is invalid (e.g., replication factor is zero, gas price is too low)\n    /// @param parameterName The name of the invalid parameter\n    /// @param value The provided invalid value\n    /// @param minimumRequired The minimum required value for the parameter\n    error InvalidParameter(string parameterName, uint256 value, uint256 minimumRequired);\n\n    /// @notice Error thrown when attempting to post a request with an ID that already exists\n    /// @param requestId The ID that was already used for a previous request\n    error RequestAlreadyExists(bytes32 requestId);\n\n    /// @notice Error thrown when trying to access a request that doesn't exist\n    /// @param requestId The ID of the non-existent request\n    error RequestNotFound(bytes32 requestId);\n\n    /// @notice Error thrown when the transfer of fees fails\n    error FeeTransferFailed();\n\n    /// @notice Retrieves a stored data request by its unique identifier.\n    /// @param id The unique identifier of the request to retrieve.\n    /// @return request The details of the requested data.\n    function getRequest(bytes32 id) external view returns (SedaDataTypes.Request memory);\n\n    /// @notice Allows users to post a new data request.\n    /// @param inputs The input parameters for the data request.\n    /// @return requestId The unique identifier for the posted request.\n    function postRequest(SedaDataTypes.RequestInputs calldata inputs) external payable returns (bytes32);\n}\n"
    },
    "@seda-protocol/evm/contracts/interfaces/IResultHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {SedaDataTypes} from \"../libraries/SedaDataTypes.sol\";\n\n/// @title IResultHandler\n/// @author Open Oracle Association\n/// @notice Interface for handling result posting and retrieval\ninterface IResultHandler {\n    /// @notice Emitted when a new result is successfully posted\n    /// @param requestId The unique identifier of the request that the result belongs to\n    /// @param resultId The unique identifier of the posted result\n    event ResultPosted(bytes32 indexed requestId, bytes32 indexed resultId);\n\n    /// @notice Error thrown when the provided result proof fails verification\n    /// @param resultId The ID of the result with invalid proof\n    error InvalidResultProof(bytes32 resultId);\n\n    /// @notice Error thrown when attempting to post a result that already exists\n    /// @param requestId The ID of the request that already has a result\n    error ResultAlreadyExists(bytes32 requestId);\n\n    /// @notice Error thrown when trying to access a result that doesn't exist\n    /// @param requestId The ID of the request with no associated result\n    error ResultNotFound(bytes32 requestId);\n\n    /// @notice Retrieves a result by its ID\n    /// @param requestId The unique identifier of the request\n    /// @return The result data associated with the given ID\n    function getResult(bytes32 requestId) external view returns (SedaDataTypes.Result memory);\n\n    /// @notice Posts a new result with a proof\n    /// @param result The result data to be posted\n    /// @param batchHeight The height of the batch the result belongs to\n    /// @param proof The proof associated with the result\n    /// @return resultId The unique identifier of the posted result\n    function postResult(\n        SedaDataTypes.Result calldata result,\n        uint64 batchHeight,\n        bytes32[] memory proof\n    ) external returns (bytes32);\n\n    /// @notice Returns the address of the Seda prover contract\n    /// @return The address of the Seda prover contract\n    function getSedaProver() external view returns (address);\n}\n"
    },
    "@seda-protocol/evm/contracts/interfaces/ISedaCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IResultHandler} from \"./IResultHandler.sol\";\nimport {IRequestHandler} from \"./IRequestHandler.sol\";\nimport {SedaDataTypes} from \"../libraries/SedaDataTypes.sol\";\n\n/// @title ISedaCoreV1\n/// @author Open Oracle Association\n/// @notice Interface for the main Seda protocol contract that handles both requests and results\ninterface ISedaCore is IResultHandler, IRequestHandler {\n    /// @notice Enum representing different types of fee distributions\n    /// @dev Used to identify fee types in events and fee distribution logic\n    /// @param REQUEST Fee paid to solver submitting the data request to SEDA network\n    /// @param RESULT Fee paid to solver submitting the data result from SEDA network\n    /// @param BATCH Fee paid to solver that submitted the batch containing the result\n    /// @param REFUND Fee refunded back to the original requestor\n    enum FeeType {\n        REQUEST,\n        RESULT,\n        BATCH,\n        REFUND,\n        WITHDRAW\n    }\n\n    /// @notice Aggregates request data and fees to help solvers evaluate pending requests\n    /// @dev Used as return type for getPendingRequests() view function, not for storage\n    struct PendingRequest {\n        bytes32 id;\n        SedaDataTypes.Request request;\n        address requestor;\n        uint256 timestamp;\n        uint256 requestFee;\n        uint256 resultFee;\n        uint256 batchFee;\n    }\n\n    /// @notice Emitted when fees are distributed for a data request and result\n    /// @param requestId The unique identifier for the data request\n    /// @param recipient The address receiving the fee distribution\n    /// @param amount The amount of fees distributed to the recipient\n    /// @param feeType The type of fee being distributed (REQUEST, RESULT, BATCH, REFUND, or WITHDRAW)\n    event FeeDistributed(bytes32 indexed requestId, address indexed recipient, uint256 amount, FeeType indexed feeType);\n\n    /// @notice Emitted when fees are updated for an existing request\n    /// @param requestId The unique identifier of the request being updated\n    /// @param amount The absolute fee amount being increased\n    /// @param feeType The type of fee being updated (REQUEST, RESULT, or BATCH)\n    event FeeUpdated(bytes32 indexed requestId, uint256 amount, FeeType feeType);\n\n    /// @notice Emitted when the timeout period is updated\n    /// @param newTimeoutPeriod The new timeout period in seconds\n    event TimeoutPeriodUpdated(uint256 newTimeoutPeriod);\n\n    /// @notice Error thrown when the fee amount is not equal to the sum of the request, result, and batch fees\n    /// @param providedFee The fee amount provided by the user\n    /// @param expectedFee The expected fee amount\n    error InvalidFeeAmount(uint256 providedFee, uint256 expectedFee);\n\n    /// @notice Error thrown when attempting to set the timeout period to zero\n    error InvalidTimeoutPeriod();\n\n    /// @notice Error thrown when attempting to update fees but no fees were actually changed\n    /// @param requestId The ID of the request that was attempted to be updated\n    error NoFeesUpdated(bytes32 requestId);\n\n    /// @notice Error thrown when a request has already been resolved\n    /// @param requestId The ID of the request that was attempted to be resolved\n    error RequestAlreadyResolved(bytes32 requestId);\n\n    /// @notice Error thrown when a request has not reached its timeout period yet\n    /// @param requestId The ID of the request that was attempted to be withdrawn\n    /// @param currentTime The current block timestamp\n    /// @param timeoutTime The timestamp when the request will be eligible for withdrawal\n    error RequestNotTimedOut(bytes32 requestId, uint256 currentTime, uint256 timeoutTime);\n\n    /// @notice Posts a request with associated fees\n    /// @param inputs The input parameters for the data request\n    /// @param requestFee Fee paid to result submitter\n    /// @param resultFee Fee for result submission\n    /// @param batchFee Fee for batch processing\n    /// @return requestId The unique identifier for the posted request\n    function postRequest(\n        SedaDataTypes.RequestInputs calldata inputs,\n        uint256 requestFee,\n        uint256 resultFee,\n        uint256 batchFee\n    ) external payable returns (bytes32);\n\n    /// @notice Increases the fees for an existing request. New fees must be greater than current fees.\n    /// @param requestId The unique identifier of the request to update\n    /// @param additionalRequestFee Additional fee to add for request submission\n    /// @param additionalResultFee Additional fee to add for result submission\n    /// @param additionalBatchFee Additional fee to add for batch processing\n    function increaseFees(\n        bytes32 requestId,\n        uint256 additionalRequestFee,\n        uint256 additionalResultFee,\n        uint256 additionalBatchFee\n    ) external payable;\n\n    /// @notice Retrieves a paginated list of pending requests\n    /// @param offset The starting position in the list\n    /// @param limit The maximum number of requests to return\n    /// @return An array of PendingRequest structs\n    function getPendingRequests(uint256 offset, uint256 limit) external view returns (PendingRequest[] memory);\n\n    /// @notice Returns the address of the fee manager contract\n    /// @return The address of the fee manager\n    function getFeeManager() external view returns (address);\n}\n"
    },
    "@seda-protocol/evm/contracts/libraries/SedaDataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title SedaDataTypes Library\n/// @author Open Oracle Association\n/// @notice Contains data structures and utility functions for the SEDA protocol\nlibrary SedaDataTypes {\n    string internal constant VERSION = \"0.0.1\";\n\n    /// @notice Input parameters for creating a data request\n    struct RequestInputs {\n        /// Identifier of Execution WASM binary\n        bytes32 execProgramId;\n        /// Identifier of Tally WASM binary\n        bytes32 tallyProgramId;\n        /// Amount of SEDA tokens per gas unit\n        uint128 gasPrice;\n        /// Maximum of gas units for DR Execution\n        uint64 execGasLimit;\n        /// Maximum of gas units for DR Tally\n        uint64 tallyGasLimit;\n        /// Amount of required DR executors\n        uint16 replicationFactor;\n        /// Inputs for Execution WASM binary\n        bytes execInputs;\n        /// Inputs for Tally WASM binary\n        bytes tallyInputs;\n        /// Filter applied before tally execution\n        bytes consensusFilter;\n        /// Public info attached to DR\n        bytes memo;\n    }\n\n    /// @notice Full data request structure\n    struct Request {\n        /// Identifier of Execution WASM binary\n        bytes32 execProgramId;\n        /// Identifier of Tally WASM binary\n        bytes32 tallyProgramId;\n        /// Amount of SEDA tokens per gas unit\n        uint128 gasPrice;\n        /// Maximum of gas units for DR Execution\n        uint64 execGasLimit;\n        /// Maximum of gas units for DR Tally\n        uint64 tallyGasLimit;\n        /// Amount of required DR executors\n        uint16 replicationFactor;\n        /// Semantic Version\n        string version;\n        /// Inputs for Execution WASM binary\n        bytes execInputs;\n        /// Inputs for Tally WASM binary\n        bytes tallyInputs;\n        /// Filter to be applied before tally execution\n        bytes consensusFilter;\n        /// Public info attached to DR\n        bytes memo;\n    }\n\n    /// @notice Result of a data request execution\n    struct Result {\n        /// Data Request Identifier\n        bytes32 drId;\n        /// Gas used by the complete data request execution\n        uint128 gasUsed;\n        /// Block Height at which data request was finalized\n        uint64 blockHeight;\n        /// The timestamp of the block the data result is included\n        uint64 blockTimestamp;\n        /// True or false whether the reveal results are in consensus or not (≥ 66%)\n        bool consensus;\n        /// Exit code of Tally WASM binary execution\n        uint8 exitCode;\n        /// Semantic Version\n        string version;\n        /// Result from Tally WASM binary execution\n        bytes result;\n        /// Payback address set by the relayer\n        bytes paybackAddress;\n        /// Payload set by SEDA Protocol (e.g. OEV-enabled data requests)\n        bytes sedaPayload;\n    }\n\n    /// @notice Represents a batch of data request results\n    /// @dev This struct is used in the batch verification process\n    struct Batch {\n        uint64 batchHeight;\n        uint64 blockHeight;\n        bytes32 validatorsRoot;\n        bytes32 resultsRoot;\n        bytes32 provingMetadata;\n    }\n\n    /// @notice Proof structure for validator verification\n    /// @dev Used in the validator set verification process\n    struct ValidatorProof {\n        uint32 votingPower;\n        address signer;\n        bytes32[] merkleProof;\n    }\n\n    /// @notice Derives a unique batch ID from a Batch struct\n    /// @param batch The Batch struct to derive the ID from\n    /// @return The derived batch ID\n    function deriveBatchId(Batch memory batch) internal pure returns (bytes32) {\n        return\n            keccak256(\n                bytes.concat(\n                    bytes8(batch.batchHeight),\n                    bytes8(batch.blockHeight),\n                    batch.validatorsRoot,\n                    batch.resultsRoot,\n                    batch.provingMetadata\n                )\n            );\n    }\n\n    /// @notice Derives a unique request ID from RequestInputs\n    /// @param inputs The RequestInputs struct to derive the ID from\n    /// @return The derived request ID\n    function deriveRequestId(RequestInputs memory inputs) internal pure returns (bytes32) {\n        return\n            keccak256(\n                bytes.concat(\n                    keccak256(bytes(SedaDataTypes.VERSION)),\n                    inputs.execProgramId,\n                    keccak256(inputs.execInputs),\n                    bytes8(inputs.execGasLimit),\n                    inputs.tallyProgramId,\n                    keccak256(inputs.tallyInputs),\n                    bytes8(inputs.tallyGasLimit),\n                    bytes2(inputs.replicationFactor),\n                    keccak256(inputs.consensusFilter),\n                    bytes16(inputs.gasPrice),\n                    keccak256(inputs.memo)\n                )\n            );\n    }\n\n    /// @notice Derives a unique result ID from a Result struct\n    /// @param result The Result struct to derive the ID from\n    /// @return The derived result ID\n    function deriveResultId(Result memory result) internal pure returns (bytes32) {\n        return\n            keccak256(\n                bytes.concat(\n                    keccak256(bytes(SedaDataTypes.VERSION)),\n                    result.drId,\n                    result.consensus ? bytes1(0x01) : bytes1(0x00),\n                    bytes1(result.exitCode),\n                    keccak256(result.result),\n                    bytes8(result.blockHeight),\n                    bytes8(result.blockTimestamp),\n                    bytes16(result.gasUsed),\n                    keccak256(result.paybackAddress),\n                    keccak256(result.sedaPayload)\n                )\n            );\n    }\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * NOTICE: This is an example contract to demonstrate SEDA network functionality.\n * It is for educational purposes only and should not be used in production.\n */\n\npragma solidity 0.8.28;\n\nimport {ISedaCore} from \"@seda-protocol/evm/contracts/interfaces/ISedaCore.sol\";\nimport {SedaDataTypes} from \"@seda-protocol/evm/contracts/libraries/SedaDataTypes.sol\";\n\n/**\n * @title PriceFeed\n * @author Open Oracle Association\n * @notice An example showing how to create and interact with SEDA network requests.\n * @dev This contract demonstrates basic SEDA request creation and result fetching.\n */\ncontract PriceFeed {\n    /// @notice Instance of the SedaCore contract\n    ISedaCore public immutable SEDA_CORE;\n\n    /// @notice ID of the request WASM binary on the SEDA network\n    bytes32 public immutable ORACLE_PROGRAM_ID;\n\n    /// @notice ID of the most recent request\n    bytes32 public requestId;\n\n    /// @notice Last requested pair string\n    string public lastPair;\n\n    /// @notice Latest stored result per pair (scaled 1e8)\n    mapping(bytes32 => uint256) public latestByPair;\n\n    /// @notice Latest request id per pair\n    mapping(bytes32 => bytes32) public requestIdByPair;\n\n    /// @notice Thrown when trying to fetch results before any request is transmitted\n    error RequestNotTransmitted();\n\n    /// @notice Emitted when a new request is posted\n    event RequestPosted(bytes32 indexed requestId);\n\n    /**\n     * @notice Sets up the contract with SEDA network parameters\n     * @param _sedaCoreAddress Address of the SedaCore contract\n     * @param _oracleProgramId ID of the WASM binary for handling requests\n     */\n    constructor(address _sedaCoreAddress, bytes32 _oracleProgramId) {\n        SEDA_CORE = ISedaCore(_sedaCoreAddress);\n        ORACLE_PROGRAM_ID = _oracleProgramId;\n        lastPair = \"WCRO-USDC\";\n    }\n\n    /**\n     * @notice Creates a new price request on the SEDA network\n     * @dev Demonstrates how to structure and send a request to SEDA\n     * @param requestFee The fee for the request\n     * @param resultFee The fee for the result\n     * @param batchFee The fee for the batch\n     * @return The ID of the created request\n     */\n    function transmit(uint256 requestFee, uint256 resultFee, uint256 batchFee) external payable returns (bytes32) {\n        return _transmitPair(lastPair, requestFee, resultFee, batchFee);\n    }\n\n    /**\n     * @notice Creates a new price request for a specific pair\n     * @param pair Pair string (e.g. \"WCRO-USDC\")\n     * @param requestFee The fee for the request\n     * @param resultFee The fee for the result\n     * @param batchFee The fee for the batch\n     * @return The ID of the created request\n     */\n    function transmitPair(\n        string calldata pair,\n        uint256 requestFee,\n        uint256 resultFee,\n        uint256 batchFee\n    ) external payable returns (bytes32) {\n        return _transmitPair(pair, requestFee, resultFee, batchFee);\n    }\n\n    /**\n     * @notice Updates the stored latest result for a pair\n     * @param pair Pair string (e.g. \"WCRO-USDC\")\n     * @return The latest result value (scaled 1e8) or 0 on failure\n     */\n    function syncLatest(string calldata pair) external returns (uint256) {\n        bytes32 pairKey = _pairKey(pair);\n        bytes32 pairRequestId = requestIdByPair[pairKey];\n        if (pairRequestId == bytes32(0)) revert RequestNotTransmitted();\n\n        uint256 value = _readResult(pairRequestId);\n        if (value != 0) {\n            latestByPair[pairKey] = value;\n        }\n        return value;\n    }\n\n    /**\n     * @notice Returns the stored latest result for a pair\n     * @param pair Pair string (e.g. \"WCRO-USDC\")\n     */\n    function latest(string calldata pair) external view returns (uint256) {\n        return latestByPair[_pairKey(pair)];\n    }\n\n    function _transmitPair(\n        string memory pair,\n        uint256 requestFee,\n        uint256 resultFee,\n        uint256 batchFee\n    ) internal returns (bytes32) {\n        SedaDataTypes.RequestInputs memory inputs = SedaDataTypes.RequestInputs(\n            ORACLE_PROGRAM_ID, // execProgramId (Execution WASM binary ID)\n            ORACLE_PROGRAM_ID, // tallyProgramId (same as execProgramId in this example)\n            2000, // gasPrice (SEDA tokens per gas unit)\n            50000000000000, // execGasLimit (within uint64 range)\n            20000000000000, // tallyGasLimit (within uint64 range)\n            1, // replicationFactor (number of required DR executors)\n            _formatExecInputs(pair), // execInputs (Inputs for Execution WASM)\n            hex\"00\", // tallyInputs\n            hex\"00\", // consensusFilter (set to `None`)\n            abi.encodePacked(block.number) // memo (Additional public info)\n        );\n\n        // Pass the msg.value as fees to the SEDA core\n        requestId = SEDA_CORE.postRequest{value: msg.value}(inputs, requestFee, resultFee, batchFee);\n        emit RequestPosted(requestId);\n\n        lastPair = pair;\n        requestIdByPair[_pairKey(pair)] = requestId;\n        return requestId;\n    }\n\n    /**\n     * @notice Retrieves the result of the latest request\n     * @dev Shows how to fetch and interpret SEDA request results\n     * @return The price as uint128, or 0 if no consensus was reached\n     */\n    function latestAnswer() public view returns (uint128) {\n        if (requestId == bytes32(0)) revert RequestNotTransmitted();\n\n        uint256 value = _readResult(requestId);\n        if (value > type(uint128).max) {\n            return 0;\n        }\n        return uint128(value);\n    }\n\n    function _readResult(bytes32 id) internal view returns (uint256) {\n        SedaDataTypes.Result memory result = SEDA_CORE.getResult(id);\n        if (!(result.consensus && result.exitCode == 0)) {\n            return 0;\n        }\n        if (result.result.length < 32) {\n            return 0;\n        }\n        return abi.decode(result.result, (uint256));\n    }\n\n    function _formatExecInputs(string memory pair) internal pure returns (bytes memory) {\n        return abi.encodePacked('{\"pair\":\"', pair, '\"}');\n    }\n\n    function _pairKey(string memory pair) internal pure returns (bytes32) {\n        return keccak256(bytes(pair));\n    }\n}\n"
    },
    "contracts/SEDAOracleConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * NOTICE: Example contract for Cronos EVM consuming relayed SEDA results.\n * This is for MVP/demo use and does NOT verify cryptographic proofs.\n */\n\npragma solidity 0.8.28;\n\n/**\n * @title SEDAOracleConsumer\n * @notice Stores relayed oracle results keyed by pair hash.\n * @dev Relayer-trusted model for MVP. Proof validation can be added later.\n */\ncontract SEDAOracleConsumer {\n    /// @notice Immutable SEDA oracle program id (bytes32)\n    bytes32 public immutable oracleProgramId;\n\n    /// @notice Authorized relayer address\n    address public relayer;\n\n    /// @notice Contract owner\n    address public owner;\n\n    /// @notice Latest values per pair (int256[4], 1e6 scale)\n    mapping(bytes32 => int256[4]) public latestByPair;\n\n    /// @notice Latest request id per pair\n    mapping(bytes32 => bytes32) public lastRequestIdByPair;\n\n    /// @notice Request ids already processed\n    mapping(bytes32 => bool) public seenRequest;\n\n    error NotOwner();\n    error NotRelayer();\n    error InvalidProof();\n    error AlreadyProcessed();\n\n    event ResultSubmitted(bytes32 indexed requestId, bytes32 indexed pair, int256[4] values);\n    event RelayerUpdated(address indexed relayer);\n\n    constructor(bytes32 _oracleProgramId, address _relayer) {\n        oracleProgramId = _oracleProgramId;\n        relayer = _relayer;\n        owner = msg.sender;\n    }\n\n    function setRelayer(address _relayer) external {\n        if (msg.sender != owner) revert NotOwner();\n        relayer = _relayer;\n        emit RelayerUpdated(_relayer);\n    }\n\n    /**\n     * @notice Submit a relayed result.\n     * @dev `sedaProof` is expected to be abi.encode(oracleProgramId) for MVP.\n     */\n    /// values[0] = fair_price (1e6)\n    /// values[1] = confidence_score (1e6)\n    /// values[2] = max_safe_execution_size (1e6)\n    /// values[3] = flags (bitmask: bit0 = CRITICAL_DIVERGENCE, bit1 = LOW_LIQUIDITY, bit2 = UNSAFE_CONFIDENCE)\n    function submitResult(\n        bytes32 requestId,\n        bytes32 pair,\n        int256[4] calldata values,\n        bytes calldata sedaProof\n    ) external {\n        if (msg.sender != relayer) revert NotRelayer();\n        if (seenRequest[requestId]) revert AlreadyProcessed();\n\n        if (sedaProof.length > 0) {\n            bytes32 proofId = abi.decode(sedaProof, (bytes32));\n            if (proofId != oracleProgramId) revert InvalidProof();\n        }\n\n        seenRequest[requestId] = true;\n        latestByPair[pair] = values;\n        lastRequestIdByPair[pair] = requestId;\n\n        emit ResultSubmitted(requestId, pair, values);\n    }\n\n    function getLatest(bytes32 pair) external view returns (int256[4] memory) {\n        return latestByPair[pair];\n    }\n\n    function getLatestRequestId(bytes32 pair) external view returns (bytes32) {\n        return lastRequestIdByPair[pair];\n    }\n}\n"
    },
    "contracts/USX402.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title USX402\n * @notice Minimal synthetic USD-like ERC20 with a trusted relayer as the sole minter/burner.\n * @dev Peg enforcement and economic checks are handled externally by the relayer/oracle.\n */\ncontract USX402 is ERC20 {\n    // --- Roles ---\n    address public owner;\n    address public minter;\n    bool public paused;\n\n    // --- Events ---\n    event Minted(address indexed to, uint256 amount);\n    event Burned(address indexed from, uint256 amount);\n    event MinterUpdated(address indexed oldMinter, address indexed newMinter);\n    event Paused();\n    event Unpaused();\n\n    // --- Modifiers ---\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"USX402: not owner\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"USX402: not minter\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"USX402: paused\");\n        _;\n    }\n\n    constructor(address initialOwner, address initialMinter) ERC20(\"USX402\", \"USX402\") {\n        require(initialOwner != address(0), \"USX402: owner zero\");\n        require(initialMinter != address(0), \"USX402: minter zero\");\n        owner = initialOwner;\n        minter = initialMinter;\n        emit MinterUpdated(address(0), initialMinter);\n    }\n\n    /**\n     * @notice Mint new tokens to a user.\n     */\n    function mint(address to, uint256 amount) external onlyMinter whenNotPaused {\n        _mint(to, amount);\n        emit Minted(to, amount);\n    }\n\n    /**\n     * @notice Burn tokens from any account WITHOUT allowance.\n     * @dev TRUST ASSUMPTION: The minter is a trusted relayer and may burn tokens\n     * from arbitrary accounts as part of protocol-controlled settlement,\n     * liquidation, or off-chain redemption flows.\n     */\n    function burn(address from, uint256 amount) external onlyMinter whenNotPaused {\n        _burn(from, amount);\n        emit Burned(from, amount);\n    }\n\n    function setMinter(address newMinter) external onlyOwner {\n        require(newMinter != address(0), \"USX402: minter zero\");\n        address oldMinter = minter;\n        minter = newMinter;\n        emit MinterUpdated(oldMinter, newMinter);\n    }\n\n    function pause() external onlyOwner {\n        paused = true;\n        emit Paused();\n    }\n\n    function unpause() external onlyOwner {\n        paused = false;\n        emit Unpaused();\n    }\n\n    function version() external pure returns (string memory) {\n        return \"USX402-v0.1-x402\";\n    }\n\n    function _update(address from, address to, uint256 amount) internal override {\n        require(!paused, \"USX402: paused\");\n        super._update(from, to, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}